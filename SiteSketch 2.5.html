<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SiteSketch - Trassenaufnahme</title>
    <style>
        :root {
            --primary: #0066FF; --primary-dark: #0052CC; --primary-light: #E6F0FF;
            --success: #00C853; --warning: #FFB300; --danger: #FF3D00;
            --bg: #F8FAFC; --bg-card: #FFFFFF; --text: #1A1A2E;
            --text-secondary: #64748B; --text-muted: #94A3B8;
            --border: #E2E8F0; --border-light: #F1F5F9;
            --shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1);
            --radius: 10px; --radius-lg: 16px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); height: 100%; overflow: hidden; }
        #app { height: 100%; display: flex; flex-direction: column; }
        
        .header { background: var(--bg-card); border-bottom: 1px solid var(--border); padding: 12px 20px; display: flex; align-items: center; justify-content: space-between; gap: 16px; }
        .header-left { display: flex; align-items: center; gap: 12px; }
        .logo { display: flex; align-items: center; gap: 10px; font-weight: 700; font-size: 20px; color: var(--primary); }
        .logo-icon { width: 36px; height: 36px; background: var(--primary); border-radius: var(--radius); display: flex; align-items: center; justify-content: center; color: white; font-size: 18px; }
        .back-btn { display: none; width: 36px; height: 36px; border: none; background: var(--bg); border-radius: var(--radius); cursor: pointer; font-size: 18px; }
        .back-btn.visible { display: flex; align-items: center; justify-content: center; }
        .header-title { font-size: 16px; font-weight: 600; }
        .header-actions { display: flex; gap: 8px; }

        .btn { display: inline-flex; align-items: center; justify-content: center; gap: 8px; padding: 10px 18px; border: none; border-radius: var(--radius); font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-dark); }
        .btn-secondary { background: var(--bg); color: var(--text); border: 1px solid var(--border); }
        .btn-secondary:hover { background: var(--border-light); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-sm { padding: 6px 12px; font-size: 13px; }

        .main { flex: 1; overflow: hidden; position: relative; }
        .view { position: absolute; inset: 0; overflow-y: auto; padding: 20px; display: none; }
        .view.active { display: block; }

        .search-bar { display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; }
        .search-input { flex: 1; min-width: 200px; padding: 12px 16px; border: 1px solid var(--border); border-radius: var(--radius); font-size: 14px; }
        .search-input:focus { outline: none; border-color: var(--primary); }
        .filter-select { padding: 12px 16px; border: 1px solid var(--border); border-radius: var(--radius); font-size: 14px; min-width: 140px; }

        .project-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 16px; }
        .project-card { background: var(--bg-card); border-radius: var(--radius-lg); border: 1px solid var(--border); overflow: hidden; cursor: pointer; transition: all 0.2s; }
        .project-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); border-color: var(--primary); }
        .project-card-header { padding: 16px; border-bottom: 1px solid var(--border-light); }
        .project-card-title { font-size: 16px; font-weight: 600; margin-bottom: 4px; }
        .project-card-subtitle { font-size: 13px; color: var(--text-secondary); }
        .project-card-meta { display: flex; gap: 12px; padding: 12px 16px; background: var(--bg); font-size: 12px; color: var(--text-muted); }
        .project-card-actions { display: flex; border-top: 1px solid var(--border-light); }
        .project-action-btn { flex: 1; padding: 12px; border: none; background: none; font-size: 13px; font-weight: 500; color: var(--text-secondary); cursor: pointer; }
        .project-action-btn:hover { background: var(--primary-light); color: var(--primary); }
        .project-action-btn:not(:last-child) { border-right: 1px solid var(--border-light); }

        .status-badge { display: inline-flex; padding: 4px 10px; border-radius: 20px; font-size: 11px; font-weight: 600; text-transform: uppercase; }
        .status-offen { background: #FEF3C7; color: #D97706; }
        .status-in-arbeit { background: #DBEAFE; color: #2563EB; }
        .status-abgeschlossen { background: #D1FAE5; color: #059669; }

        .empty-state { text-align: center; padding: 60px 20px; }
        .empty-state h3 { font-size: 18px; margin-bottom: 8px; }
        .empty-state p { color: var(--text-secondary); margin-bottom: 20px; }

        .form-section { background: var(--bg-card); border-radius: var(--radius-lg); border: 1px solid var(--border); padding: 24px; margin-bottom: 20px; }
        .form-section-title { font-size: 16px; font-weight: 600; margin-bottom: 16px; }
        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; }
        .form-group { display: flex; flex-direction: column; gap: 6px; }
        .form-group.full-width { grid-column: 1 / -1; }
        .form-label { font-size: 13px; font-weight: 500; color: var(--text-secondary); }
        .form-label.required::after { content: ' *'; color: var(--danger); }
        .form-input, .form-textarea, .form-select { padding: 10px 14px; border: 1px solid var(--border); border-radius: var(--radius); font-size: 14px; }
        .form-input:focus, .form-textarea:focus { outline: none; border-color: var(--primary); }
        .form-textarea { min-height: 80px; resize: vertical; }
        .form-actions { display: flex; justify-content: flex-end; gap: 12px; margin-top: 20px; }

        .tabs { display: flex; background: var(--bg-card); border-bottom: 1px solid var(--border); padding: 0 20px; overflow-x: auto; }
        .tab { padding: 14px 20px; border: none; background: none; font-size: 14px; font-weight: 500; color: var(--text-secondary); cursor: pointer; position: relative; }
        .tab.active { color: var(--primary); }
        .tab.active::after { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 3px; background: var(--primary); }
        .tab-content { display: none; padding: 20px; height: calc(100% - 49px); overflow-y: auto; }
        .tab-content.active { display: block; }

        .photo-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 12px; }
        .photo-card { position: relative; aspect-ratio: 4/3; border-radius: var(--radius); overflow: hidden; background: var(--bg); border: 1px solid var(--border); cursor: pointer; }
        .photo-card:hover { box-shadow: var(--shadow); }
        .photo-card img { width: 100%; height: 100%; object-fit: cover; }
        .photo-card-badge { position: absolute; top: 8px; right: 8px; background: var(--primary); color: white; padding: 2px 8px; border-radius: 12px; font-size: 10px; font-weight: 600; }
        .add-photo-card { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px; border: 2px dashed var(--border); color: var(--text-secondary); font-size: 13px; }
        .add-photo-card:hover { border-color: var(--primary); color: var(--primary); }

        .map-container { height: 100%; display: flex; flex-direction: column; }
        .map-toolbar { display: flex; gap: 8px; padding: 12px; background: var(--bg-card); border-bottom: 1px solid var(--border); }
        #map { flex: 1; background: #E8E8E8; position: relative; }
        .map-controls { position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 4px; z-index: 10; }
        .map-control-btn { width: 36px; height: 36px; background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius); cursor: pointer; font-size: 18px; }
        .geocode-status { padding: 40px; text-align: center; color: var(--text-secondary); }
        .geocode-error { background: #FEF2F2; color: #DC2626; padding: 16px; border-radius: var(--radius); margin: 16px; text-align: center; }

        .quantity-table { width: 100%; border-collapse: collapse; font-size: 14px; }
        .quantity-table th, .quantity-table td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border); }
        .quantity-table th { background: var(--bg); font-weight: 600; font-size: 12px; text-transform: uppercase; }
        .quantity-input { width: 80px; padding: 6px; border: 1px solid var(--border); border-radius: 6px; text-align: right; }

        .editor-container { position: fixed; inset: 0; background: var(--bg); z-index: 1000; display: none; flex-direction: column; }
        .editor-container.active { display: flex; }
        .editor-header { background: var(--bg-card); border-bottom: 1px solid var(--border); padding: 12px 16px; display: flex; align-items: center; justify-content: space-between; }
        .editor-toolbar { display: flex; gap: 6px; background: var(--bg); padding: 8px; overflow-x: auto; border-bottom: 1px solid var(--border); flex-wrap: wrap; position: relative; }
        .toolbar-meta { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; background: var(--bg-card); padding: 6px 8px; border: 1px solid var(--border); border-radius: 10px; }
        .toolbar-meta label { font-size: 12px; color: var(--text-secondary); }
        .toolbar-select { padding: 8px 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-card); font-size: 12px; }
        .tool-btn { min-width: 44px; min-height: 44px; padding: 8px 12px; border: 2px solid transparent; background: var(--bg-card); border-radius: var(--radius); font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; position: relative; }
        .tool-btn.active { background: var(--primary); color: white; border-color: var(--primary); }
        .tool-color { width: 16px; height: 16px; border-radius: 50%; }
        .tool-submenu { position: absolute; background: var(--bg-card); border: 2px solid var(--border); border-radius: var(--radius); padding: 8px; display: flex; flex-direction: column; gap: 4px; z-index: 1000; box-shadow: var(--shadow-lg); margin-top: 4px; max-height: 400px; overflow-y: auto; }
        .editor-canvas-wrapper { flex: 1; overflow: auto; display: flex; align-items: center; justify-content: center; background: #2A2A2A; padding: 20px; }
        #editorCanvas { display: block; background: white; box-shadow: var(--shadow-lg); }
        .editor-sidebar { width: 260px; background: var(--bg-card); border-left: 1px solid var(--border); padding: 16px; overflow-y: auto; }
        .sidebar-title { font-size: 12px; font-weight: 600; text-transform: uppercase; color: var(--text-secondary); margin-bottom: 12px; }
        .trasse-props { position: absolute; top: 12px; right: 12px; background: var(--bg-card); border: 1px solid var(--border); border-radius: 10px; padding: 10px; box-shadow: var(--shadow-lg); display: none; z-index: 1100; width: 240px; }
        .trasse-props h4 { margin: 0 0 8px; font-size: 13px; }
        .trasse-props .row { display: flex; flex-direction: column; gap: 6px; }
        .trasse-props select { padding: 8px 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-card); font-size: 12px; }
        .legend-item { display: flex; align-items: center; gap: 10px; padding: 6px 0; font-size: 13px; }
        .layer-item { display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--bg); border-radius: 6px; margin-bottom: 4px; font-size: 12px; cursor: pointer; }
        .layer-item.selected { background: var(--primary-light); }

        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 2000; padding: 20px; }
        .modal-overlay.active { display: flex; }
        .modal { background: var(--bg-card); border-radius: var(--radius-lg); max-width: 500px; width: 100%; max-height: 90vh; overflow-y: auto; }
        .modal-header { padding: 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .modal-title { font-size: 18px; font-weight: 600; }
        .modal-close { width: 32px; height: 32px; border: none; background: none; cursor: pointer; font-size: 20px; }
        .modal-body { padding: 20px; }
        .modal-footer { padding: 16px 20px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; gap: 12px; }

        .contact-list { display: flex; flex-direction: column; gap: 8px; }
        .contact-item { display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg); border-radius: var(--radius); }
        .contact-avatar { width: 40px; height: 40px; background: var(--primary-light); color: var(--primary); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 600; }
        .contact-info { flex: 1; }
        .contact-name { font-weight: 500; }
        .contact-role { font-size: 12px; color: var(--text-secondary); }

        .toast-container { position: fixed; bottom: 20px; right: 20px; z-index: 3000; }
        .toast { background: var(--text); color: white; padding: 12px 20px; border-radius: var(--radius); margin-top: 8px; animation: slideIn 0.3s; }
        .toast.success { background: var(--success); }
        .toast.error { background: var(--danger); }
        @keyframes slideIn { from { transform: translateX(100%); } to { transform: translateX(0); } }

        .loading { display: inline-block; width: 20px; height: 20px; border: 2px solid var(--border); border-top-color: var(--primary); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .file-input-hidden { position: absolute; width: 1px; height: 1px; opacity: 0; }
        .flex { display: flex; }
        .gap-2 { gap: 8px; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .mb-4 { margin-bottom: 16px; }
        .mt-2 { margin-top: 8px; }
        .text-muted { color: var(--text-muted); }
        .text-center { text-align: center; }

        .geocode-results { border: 1px solid var(--border); border-radius: var(--radius); overflow: hidden; }
        .geocode-result-item { padding: 12px; border-bottom: 1px solid var(--border-light); cursor: pointer; }
        .geocode-result-item:hover { background: var(--primary-light); }
        .geocode-result-item:last-child { border-bottom: none; }

        @media (max-width: 768px) {
            .project-grid { grid-template-columns: 1fr; }
            .form-grid { grid-template-columns: 1fr; }
            .editor-sidebar { display: none; }
            /* Toolbar mobil: vertikale Leiste links */
            .editor-toolbar {
                position: fixed;
                top: 0;
                bottom: 0;
                left: 0;
                width: 140px;
                z-index: 1200;

                flex-direction: column;
                align-items: stretch;
                flex-wrap: nowrap;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;

                gap: 8px;
                padding: 16px 10px;

                border-right: 1px solid var(--border);
                border-top: none;
                background: var(--bg-card);
            }

            /* Canvas nicht verdecken */
            .editor-canvas-wrapper {
                padding-left: 156px; /* Toolbar-Breite + Luft */
                padding-bottom: 20px;
            }

            .editor-header {
                padding-left: 156px;
            }

            /* Touch Targets */
            .tool-btn {
                min-width: 48px;
                min-height: 48px;
                padding: 10px 12px;
                font-size: 11px;
                white-space: nowrap;
                text-overflow: ellipsis;
                overflow: hidden;
                justify-content: flex-start;
            }

            /* (optional) Scrollbar verstecken */
            .editor-toolbar::-webkit-scrollbar { width: 0; height: 0; }

            /* Submenu als Bottom-Sheet */
            .tool-submenu {
                position: fixed !important;
                left: 12px !important;
                right: 12px !important;
                bottom: 84px !important;     /* √ºber der Toolbar */
                top: auto !important;

                max-height: 55vh !important;
                overflow: auto !important;

                border-radius: 16px !important;
                z-index: 2000 !important;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <header class="header">
            <div class="header-left">
                <button class="back-btn" id="backBtn" onclick="app.goBack()">‚Üê</button>
                <div class="logo"><div class="logo-icon">‚ö°</div><span>SiteSketch</span></div>
                <span class="header-title" id="headerTitle"></span>
            </div>
            <div class="header-actions" id="headerActions"></div>
        </header>
        <main class="main">
            <div class="view active" id="projectListView">
                <div class="search-bar">
                    <input type="text" class="search-input" placeholder="Projekte durchsuchen..." id="searchInput" oninput="app.filterProjects()">
                    <select class="filter-select" id="statusFilter" onchange="app.filterProjects()">
                        <option value="">Alle Status</option>
                        <option value="offen">Offen</option>
                        <option value="in-arbeit">In Arbeit</option>
                        <option value="abgeschlossen">Abgeschlossen</option>
                    </select>
                    <button class="btn btn-primary" onclick="app.showCreateProject()">+ Neues Projekt</button>
                </div>
                <div class="project-grid" id="projectGrid"></div>
            </div>
            <div class="view" id="projectFormView">
                <form id="projectForm" onsubmit="app.saveProject(event)">
                    <div class="form-section">
                        <h3 class="form-section-title">üìÅ Projektdaten</h3>
                        <div class="form-grid">
                            <div class="form-group"><label class="form-label required">Projektnummer</label><input type="text" class="form-input" name="projectNumber" required></div>
                            <div class="form-group"><label class="form-label required">Projektname</label><input type="text" class="form-input" name="projectName" required></div>
                            <div class="form-group"><label class="form-label required">Kunde</label><input type="text" class="form-input" name="customer" required></div>
                            <div class="form-group"><label class="form-label">Status</label><select class="form-select" name="status"><option value="offen">Offen</option><option value="in-arbeit">In Arbeit</option><option value="abgeschlossen">Abgeschlossen</option></select></div>
                            <div class="form-group"><label class="form-label">Ersteller</label><input type="text" class="form-input" name="creator" placeholder="Name des Erstellers"></div>
                            <div class="form-group full-width"><label class="form-label">Beschreibung</label><textarea class="form-textarea" name="description"></textarea></div>
                        </div>
                    </div>
                    <div class="form-section">
                        <h3 class="form-section-title">üìç Projektadresse</h3>
                        <div class="form-grid">
                            <div class="form-group"><label class="form-label required">Stra√üe</label><input type="text" class="form-input" name="street" required></div>
                            <div class="form-group"><label class="form-label required">Hausnr.</label><input type="text" class="form-input" name="houseNumber" required></div>
                            <div class="form-group"><label class="form-label required">PLZ</label><input type="text" class="form-input" name="postalCode" required></div>
                            <div class="form-group"><label class="form-label required">Ort</label><input type="text" class="form-input" name="city" required></div>
                            <div class="form-group"><label class="form-label required">Land</label><input type="text" class="form-input" name="country" value="Deutschland" required></div>
                        </div>
                    </div>
                    <div class="form-section">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="form-section-title" style="margin:0">üë• Ansprechpartner</h3>
                            <button type="button" class="btn btn-secondary btn-sm" onclick="app.showContactModal()">+ Hinzuf√ºgen</button>
                        </div>
                        <div class="contact-list" id="contactList"><p class="text-muted text-center">Noch keine Ansprechpartner</p></div>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="btn btn-secondary" onclick="app.cancelProjectForm()">Abbrechen</button>
                        <button type="submit" class="btn btn-primary">Speichern</button>
                    </div>
                </form>
            </div>
            <div class="view" id="projectDetailView">
                <div class="tabs">
                    <button class="tab active" data-tab="photos" onclick="app.switchTab('photos')">üì∑ Fotos</button>
                    <button class="tab" data-tab="map" onclick="app.switchTab('map')">üó∫Ô∏è Karte</button>
                    <button class="tab" data-tab="quantities" onclick="app.switchTab('quantities')">üìã Mengen</button>
                </div>
                <div class="tab-content active" id="photosTab"><div class="photo-grid" id="photoGrid"></div></div>
                <div class="tab-content" id="mapTab">
                    <div class="map-container">
                        <div class="map-toolbar">
                            <button class="btn btn-secondary btn-sm" onclick="app.saveMapSnapshot()">üì∑ Karte speichern</button>
                            <button class="btn btn-secondary btn-sm" onclick="app.refreshGeocode()">üîÑ Neu laden</button>
                        </div>
                        <div id="map"><div class="geocode-status" id="geocodeStatus"><div class="loading"></div><p class="mt-2">Adresse wird gesucht...</p></div></div>
                    </div>
                </div>
                <div class="tab-content" id="quantitiesTab">
                    <div class="form-section">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="form-section-title" style="margin:0">Mengenaufma√ü</h3>
                            <div class="flex gap-2">
                                <button class="btn btn-secondary btn-sm" onclick="app.recalculateQuantities()">üîÑ Berechnen</button>
                                <button class="btn btn-primary btn-sm" onclick="app.exportQuantityPDF()">üìÑ PDF</button>
                            </div>
                        </div>
                        <table class="quantity-table"><thead><tr><th>Pos.</th><th>Beschreibung</th><th>Einheit</th><th>Auto</th><th>Menge</th></tr></thead><tbody id="quantityTableBody"></tbody></table>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div class="editor-container" id="editorContainer">
        <div class="editor-header">
            <div class="flex items-center gap-2">
                <button class="btn btn-secondary btn-sm" onclick="app.closeEditor()">‚Üê Zur√ºck</button>
                <span id="editorTitle">Bild bearbeiten</span>
            </div>
            <div class="flex gap-2">
                <button class="btn btn-secondary btn-sm" onclick="app.editorUndo()">‚Ü∂</button>
                <button class="btn btn-secondary btn-sm" onclick="app.editorRedo()">‚Ü∑</button>
                <button class="btn btn-danger btn-sm" onclick="app.deletePhoto()">üóëÔ∏è</button>
                <button class="btn btn-primary btn-sm" onclick="app.saveEditor()">üíæ Speichern</button>
            </div>
        </div>
        <div class="editor-toolbar" id="editorToolbar"></div>
        <div class="trasse-props" id="trasseProps"></div>
        <div style="display:flex;flex:1;overflow:hidden">
            <div class="editor-canvas-wrapper"><canvas id="editorCanvas"></canvas></div>
            <div class="editor-sidebar">
                <div class="sidebar-title">Legende</div>
                <div id="legendList"></div>
                <div class="sidebar-title" style="margin-top:20px">Ebenen</div>
                <div id="layerList"></div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="contactModal">
        <div class="modal">
            <div class="modal-header"><h3 class="modal-title">Ansprechpartner</h3><button class="modal-close" onclick="app.closeContactModal()">√ó</button></div>
            <div class="modal-body">
                <div class="form-grid">
                    <div class="form-group"><label class="form-label required">Name</label><input type="text" class="form-input" id="contactName"></div>
                    <div class="form-group"><label class="form-label">Rolle</label><input type="text" class="form-input" id="contactRole"></div>
                    <div class="form-group"><label class="form-label">Telefon</label><input type="tel" class="form-input" id="contactPhone"></div>
                    <div class="form-group"><label class="form-label">E-Mail</label><input type="email" class="form-input" id="contactEmail"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="app.closeContactModal()">Abbrechen</button>
                <button class="btn btn-primary" onclick="app.addContact()">Hinzuf√ºgen</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="geocodeModal">
        <div class="modal">
            <div class="modal-header"><h3 class="modal-title">Adresse w√§hlen</h3><button class="modal-close" onclick="app.closeGeocodeModal()">√ó</button></div>
            <div class="modal-body">
                <p class="text-muted mb-4">Mehrere Treffer gefunden:</p>
                <div class="geocode-results" id="geocodeResults"></div>
            </div>
        </div>
    </div>

    <div class="toast-container" id="toastContainer"></div>
    <input type="file" class="file-input-hidden" id="cameraInput" accept="image/*" capture="environment" onchange="app.handlePhotoCapture(event)">
    <input type="file" class="file-input-hidden" id="importInput" accept="image/*" multiple onchange="app.handlePhotoImport(event)">
    <input type="file" class="file-input-hidden" id="jsonImportInput" accept=".json" onchange="app.handleJsonImport(event)">

    <script>
    // TOOLS DEFINITION
    const SURFACES = [
        { value: 'UNBEFESTIGT', label: 'Unbefestigt' },
        { value: 'GEHWEGPLATTE', label: 'Gehwegplatte' },
        { value: 'ASPHALT', label: 'Asphalt' },
        { value: 'BETON', label: 'Beton' },
        { value: 'PFLASTER', label: 'Pflaster' },
        { value: 'GESCHL_BAUWEISE', label: 'Geschl. Bauweise' }
    ];
    const DNS = [
        { value: 'DN50', label: 'DN50' },
        { value: 'DN100', label: 'DN100' }
    ];
    const TOOL_GROUPS = {
        SELECT: { id: 'SELECT', name: 'Auswahl', icon: '‚Üñ', type: 'utility' },
        INSTALLATIONSROHR: { id: 'INSTALLATIONSROHR', name: 'Installationsrohr', color: '#06B6D4', type: 'line', unit: 'm', lineWidth: 2, dash: [8,4] },
        TRASSE: { id: 'TRASSE', name: 'Trasse', color: '#FF0000', type: 'line', unit: 'm', lineWidth: 3 },
        SCHACHT: {
            id: 'SCHACHT', name: 'Schacht', icon: '‚ñ°', type: 'group',
            children: {
                SCHACHT_AZK: {
                    id: 'SCHACHT_AZK', name: 'AZK', type: 'group',
                    children: {
                        SCHACHT_AZK_NEU: { id: 'SCHACHT_AZK_NEU', name: 'Neu', color: '#10B981', type: 'point', unit: 'Stk', symbol: '‚óã' },
                        SCHACHT_AZK_BESTAND: { id: 'SCHACHT_AZK_BESTAND', name: 'Bestand', color: '#6B7280', type: 'point', unit: 'Stk', symbol: '‚óã' }
                    }
                },
                SCHACHT_DAZK: {
                    id: 'SCHACHT_DAZK', name: 'DAZK', type: 'group',
                    children: {
                        SCHACHT_DAZK_NEU: { id: 'SCHACHT_DAZK_NEU', name: 'Neu', color: '#10B981', type: 'point', unit: 'Stk', symbol: '‚ñ°' },
                        SCHACHT_DAZK_BESTAND: { id: 'SCHACHT_DAZK_BESTAND', name: 'Bestand', color: '#6B7280', type: 'point', unit: 'Stk', symbol: '‚ñ°' }
                    }
                }
            }
        },
        BOHRUNG_HAUSEINFUEHRUNG: { id: 'BOHRUNG_HAUSEINFUEHRUNG', name: 'Bohrung HE', color: '#F59E0B', type: 'point', unit: 'Stk', symbol: '‚äï' },
        BOHRUNG_WANDDURCHFUEHRUNG: { id: 'BOHRUNG_WANDDURCHFUEHRUNG', name: 'Bohrung WD', color: '#F59E0B', type: 'point', unit: 'Stk', symbol: '‚äó' },
        TEXT_CALL_OUT: { id: 'TEXT_CALL_OUT', name: 'Text', color: '#1A1A2E', type: 'text' }
    };

    
    // Flatten tools for lookup
    const TOOLS = {};
    function flattenTools(obj, parent = null) {
        Object.values(obj).forEach(tool => {
            if (tool.type !== 'group') {
                TOOLS[tool.id] = tool;
            }
            if (tool.children) {
                flattenTools(tool.children, tool);
            }
        });
    }
    flattenTools(TOOL_GROUPS);

    // DATABASE (IndexedDB with LocalStorage fallback)
    class Database {
        constructor() { this.db = null; this.useIDB = true; }
        async init() {
            return new Promise((resolve) => {
                if (!window.indexedDB) { this.useIDB = false; resolve(); return; }
                const req = indexedDB.open('SiteSketchDB', 1);
                req.onerror = () => { this.useIDB = false; resolve(); };
                req.onsuccess = (e) => { this.db = e.target.result; resolve(); };
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('projects')) {
                        const ps = db.createObjectStore('projects', { keyPath: 'id' });
                        ps.createIndex('customer', 'customer');
                    }
                    if (!db.objectStoreNames.contains('photos')) {
                        const phs = db.createObjectStore('photos', { keyPath: 'id' });
                        phs.createIndex('projectId', 'projectId');
                    }
                };
            });
        }
        async getAll(store) {
            if (!this.useIDB) return JSON.parse(localStorage.getItem('ss_' + store) || '[]');
            return new Promise((resolve) => {
                const tx = this.db.transaction([store], 'readonly');
                tx.objectStore(store).getAll().onsuccess = (e) => resolve(e.target.result);
            });
        }
        async get(store, id) {
            if (!this.useIDB) return (await this.getAll(store)).find(i => i.id === id);
            return new Promise((resolve) => {
                const tx = this.db.transaction([store], 'readonly');
                tx.objectStore(store).get(id).onsuccess = (e) => resolve(e.target.result);
            });
        }
        async put(store, item) {
            if (!this.useIDB) {
                const items = await this.getAll(store);
                const idx = items.findIndex(i => i.id === item.id);
                if (idx >= 0) items[idx] = item; else items.push(item);
                localStorage.setItem('ss_' + store, JSON.stringify(items));
                return item;
            }
            return new Promise((resolve) => {
                const tx = this.db.transaction([store], 'readwrite');
                tx.objectStore(store).put(item).onsuccess = () => resolve(item);
            });
        }
        async delete(store, id) {
            if (!this.useIDB) {
                const items = (await this.getAll(store)).filter(i => i.id !== id);
                localStorage.setItem('ss_' + store, JSON.stringify(items));
                return;
            }
            return new Promise((resolve) => {
                const tx = this.db.transaction([store], 'readwrite');
                tx.objectStore(store).delete(id).onsuccess = () => resolve();
            });
        }
        async getByIndex(store, index, value) {
            if (!this.useIDB) return (await this.getAll(store)).filter(i => i[index] === value);
            return new Promise((resolve) => {
                const tx = this.db.transaction([store], 'readonly');
                tx.objectStore(store).index(index).getAll(value).onsuccess = (e) => resolve(e.target.result);
            });
        }
    }

    // GEOCODING SERVICE
    class GeocodingService {
        constructor() { this.cache = new Map(); this.lastReq = 0; }
        async geocode(addr) {
            const str = [addr.street, addr.houseNumber, addr.postalCode, addr.city, addr.country].filter(Boolean).join(', ');
            if (this.cache.has(str)) return this.cache.get(str);
            const wait = 1100 - (Date.now() - this.lastReq);
            if (wait > 0) await new Promise(r => setTimeout(r, wait));
            try {
                const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(str)}&limit=5`, {
                    headers: { 'Accept': 'application/json' }
                });
                this.lastReq = Date.now();
                if (!res.ok) return { error: 'NETWORK_ERROR', results: [] };
                const data = await res.json();
                if (!data.length) return { error: 'NO_RESULTS', results: [] };
                const results = data.map(r => ({ lat: parseFloat(r.lat), lon: parseFloat(r.lon), displayName: r.display_name }));
                this.cache.set(str, { results });
                return { results };
            } catch (e) { 
                console.error('Geocoding error:', e);
                return { error: 'NETWORK_ERROR', results: [] }; 
            }
        }
    }

    // MAP RENDERER
    class MapRenderer {
        constructor(container) { this.container = container; this.canvas = null; this.ctx = null; this.zoom = 18; this.center = {lat:0,lon:0}; this.tiles = new Map(); this.offset = {x:0,y:0}; this.dragging = false; }
        init() {
            this.container.innerHTML = '';
            this.canvas = document.createElement('canvas');
            this.canvas.style.cssText = 'width:100%;height:100%';
            this.container.appendChild(this.canvas);
            const ctrl = document.createElement('div');
            ctrl.className = 'map-controls';
            ctrl.innerHTML = '<button class="map-control-btn" onclick="app.mapZoom(1)">+</button><button class="map-control-btn" onclick="app.mapZoom(-1)">‚àí</button>';
            this.container.appendChild(ctrl);
            this.resize();
            this.setupEvents();
        }
        resize() { const r = this.container.getBoundingClientRect(); this.canvas.width = r.width; this.canvas.height = r.height; this.ctx = this.canvas.getContext('2d'); this.render(); }
          setupEvents() {
              const canvas = this.canvas;
              let drag = null;
              canvas.onmousedown = (e) => { drag = {x:e.clientX,y:e.clientY}; };
              canvas.onmousemove = (e) => { if (!drag) return; this.offset.x += e.clientX - drag.x; this.offset.y += e.clientY - drag.y; drag = {x:e.clientX,y:e.clientY}; this.render(); };
              canvas.onmouseup = canvas.onmouseleave = () => { if (drag) this.updateCenter(); drag = null; };
              canvas.onwheel = (e) => { e.preventDefault(); this.setZoom(this.zoom + (e.deltaY > 0 ? -1 : 1)); };

              // Touch support (iOS): pan with one finger, pinch to zoom. Passive:false is needed so preventDefault works.
              let touch = null, pinchStart = null, pinchStartZoom = this.zoom;
              const touchStart = (e) => {
                  if (e.touches.length === 1) {
                      touch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                      pinchStart = null;
                  } else if (e.touches.length === 2) {
                      const dx = e.touches[0].clientX - e.touches[1].clientX;
                      const dy = e.touches[0].clientY - e.touches[1].clientY;
                      pinchStart = Math.hypot(dx, dy);
                      pinchStartZoom = this.zoom;
                  }
              };
              const touchMove = (e) => {
                  if (e.touches.length === 1 && touch) {
                      e.preventDefault();
                      this.offset.x += e.touches[0].clientX - touch.x;
                      this.offset.y += e.touches[0].clientY - touch.y;
                      touch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                      this.render();
                  } else if (e.touches.length === 2 && pinchStart) {
                      e.preventDefault();
                      const dx = e.touches[0].clientX - e.touches[1].clientX;
                      const dy = e.touches[0].clientY - e.touches[1].clientY;
                      const dist = Math.hypot(dx, dy);
                      const delta = Math.log2(dist / pinchStart);
                      this.setZoom(pinchStartZoom + delta);
                  }
              };
              const touchEnd = () => {
                  if (touch) this.updateCenter();
                  touch = null; pinchStart = null;
              };
              canvas.addEventListener('touchstart', touchStart, { passive: false });
              canvas.addEventListener('touchmove', touchMove, { passive: false });
              canvas.addEventListener('touchend', touchEnd, { passive: false });
          }
        updateCenter() {
            const cp = this.latLonToPixel(this.center.lat, this.center.lon);
            const np = this.pixelToLatLon(cp.x - this.offset.x, cp.y - this.offset.y);
            this.center = np; this.offset = {x:0,y:0};
        }
        setCenter(lat, lon) { this.center = {lat,lon}; this.offset = {x:0,y:0}; this.render(); }
        setZoom(z) { this.zoom = Math.max(1, Math.min(19, z)); this.render(); }
        latLonToPixel(lat, lon) {
            const scale = Math.pow(2, this.zoom) * 256;
            const x = ((lon + 180) / 360) * scale;
            const latRad = lat * Math.PI / 180;
            const y = (1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * scale;
            return {x,y};
        }
        pixelToLatLon(x, y) {
            const scale = Math.pow(2, this.zoom) * 256;
            const lon = (x / scale) * 360 - 180;
            const n = Math.PI - 2 * Math.PI * y / scale;
            const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
            return {lat,lon};
        }
        loadTile(z, x, y) {
            const key = `${z}/${x}/${y}`;
            if (this.tiles.has(key)) return this.tiles.get(key);
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
            img.onload = () => this.render();
            this.tiles.set(key, img);
            return img;
        }
        render() {
            if (!this.ctx) return;
            const w = this.canvas.width, h = this.canvas.height;
            this.ctx.fillStyle = '#E8E8E8'; this.ctx.fillRect(0, 0, w, h);
            const cp = this.latLonToPixel(this.center.lat, this.center.lon);
            const startX = cp.x - w/2 - this.offset.x, startY = cp.y - h/2 - this.offset.y;
            const stx = Math.floor(startX / 256), sty = Math.floor(startY / 256);
            const etx = Math.floor((startX + w) / 256), ety = Math.floor((startY + h) / 256);
            const max = Math.pow(2, this.zoom);
            for (let ty = sty; ty <= ety; ty++) {
                for (let tx = stx; tx <= etx; tx++) {
                    const wx = ((tx % max) + max) % max;
                    if (ty < 0 || ty >= max) continue;
                    const img = this.loadTile(this.zoom, wx, ty);
                    const dx = tx * 256 - startX, dy = ty * 256 - startY;
                    if (img.complete && img.naturalWidth > 0) this.ctx.drawImage(img, dx, dy, 256, 256);
                }
            }
            this.ctx.fillStyle = '#0066FF'; this.ctx.strokeStyle = '#FFF'; this.ctx.lineWidth = 3;
            this.ctx.beginPath(); this.ctx.arc(w/2 + this.offset.x, h/2 + this.offset.y, 8, 0, Math.PI*2); this.ctx.fill(); this.ctx.stroke();
            this.ctx.fillStyle = 'rgba(255,255,255,0.8)'; this.ctx.fillRect(0, h-20, w, 20);
            this.ctx.fillStyle = '#333'; this.ctx.font = '10px sans-serif'; this.ctx.fillText('¬© OpenStreetMap', 5, h-6);
        }
        async getSnapshot() {
            await new Promise(r => setTimeout(r, 500));
            const cp = this.latLonToPixel(this.center.lat, this.center.lon);
            const w = this.canvas.width, h = this.canvas.height;
            const tl = this.pixelToLatLon(cp.x - w/2, cp.y - h/2);
            const br = this.pixelToLatLon(cp.x + w/2, cp.y + h/2);
            return {
                dataUrl: this.canvas.toDataURL('image/png'),
                metadata: { centerLat: this.center.lat, centerLon: this.center.lon, zoomLevel: this.zoom, pixelWidth: w, pixelHeight: h, tileSize: 256, boundingBox: { north: tl.lat, south: br.lat, west: tl.lon, east: br.lon } }
            };
        }
    }

    // EDITOR
    class Editor {
        constructor() { 
            this.canvas = null; this.ctx = null; this.photo = null; this.image = null; 
            this.annotations = []; this.selectedTool = 'SELECT'; this.selectedAnn = null; 
            this.undoStack = []; this.redoStack = []; this.drawing = false; this.path = []; 
            this.scale = 1; this.currentMousePos = null;
            this.dragPointIndex = null; // For dragging individual points in SELECT mode
            this.currentSurface = 'GEHWEGPLATTE';
            this.currentDN = 'DN50';
        }
        init(photo, img) {
            this.photo = photo; this.image = img; this.annotations = JSON.parse(JSON.stringify(photo.annotations || []));
            this.undoStack = []; this.redoStack = []; this.selectedAnn = null; this.selectedTool = 'SELECT';
            this.dragPointIndex = null;
            this.canvas = document.getElementById('editorCanvas'); this.ctx = this.canvas.getContext('2d');
            // Canvas m√∂glichst gro√ü halten (Reserve nur f√ºr Header/Toolbar)
            const toolbarReserve = 100, headerReserve = 100, margin = 32;
            const maxW = Math.max(200, window.innerWidth - margin);
            const maxH = Math.max(200, window.innerHeight - (toolbarReserve + headerReserve));
            this.scale = Math.min(maxW / img.width, maxH / img.height, 1);
            this.canvas.width = img.width * this.scale; this.canvas.height = img.height * this.scale;
            this.setupEvents(); this.renderToolbar(); this.renderLegend(); this.renderLayers(); this.render();
        }
        setupEvents() {
            const getP = (e) => { const r = this.canvas.getBoundingClientRect(); return { x: (e.clientX - r.left) / this.scale, y: (e.clientY - r.top) / this.scale }; };
            
            this.canvas.onmousedown = (e) => {
                const p = getP(e), tool = TOOLS[this.selectedTool];
                
                if (this.selectedTool === 'SELECT') { 
                    // First check if clicking on a point of the selected annotation (for individual point dragging)
                    if (this.selectedAnn && this.selectedAnn.points) {
                        const pointIdx = this.findPointAt(p, this.selectedAnn);
                        if (pointIdx !== null) {
                            this.dragPointIndex = pointIdx;
                            this.selectedAnn._dragPoint = {...p};
                            this.saveState();
                            return;
                        }
                    }
                    // Otherwise try to select an annotation
                    this.selectedAnn = this.findAt(p); 
                    if (this.selectedAnn && this.selectedAnn.tool === 'TRASSE') this.ensureTrasseMeta(this.selectedAnn);
                    if (this.selectedAnn) this.selectedAnn._drag = {...p}; 
                    this.dragPointIndex = null;
                    this.renderLayers(); 
                    this.render(); 
                    this.updateTrasseProps();
                }
                else if (tool.type === 'line') { 
                    // Drag-to-draw: start a new line on mousedown
                    this.drawing = true;
                    this.path = [p];
                    this.saveState();
                    this.render();
                }
                else if (tool.type === 'point') { 
                    this.saveState(); 
                    this.annotations.push({ id: 'a'+Date.now(), tool: this.selectedTool, point: p }); 
                    this.renderLayers(); 
                    this.render(); 
                }
                else if (tool.type === 'text') { 
                    const t = prompt('Text:'); 
                    if (t) { 
                        this.saveState(); 
                        this.annotations.push({ id: 'a'+Date.now(), tool: this.selectedTool, point: p, text: t }); 
                        this.renderLayers(); 
                        this.render(); 
                    } 
                }
            };
            
            this.canvas.onmousemove = (e) => {
                const p = getP(e);
                this.currentMousePos = p;
                
                // Dragging individual point in SELECT mode
                if (this.selectedTool === 'SELECT' && this.selectedAnn && this.dragPointIndex !== null && this.selectedAnn._dragPoint) {
                    this.selectedAnn.points[this.dragPointIndex].x = p.x;
                    this.selectedAnn.points[this.dragPointIndex].y = p.y;
                    // Recalculate length if map snapshot
                    if (this.photo.isMapSnapshot && this.photo.mapMetadata) {
                        this.selectedAnn.computed = { lengthMeters: this.calcLength(this.selectedAnn.points) };
                    }
                    this.render();
                    return;
                }
                
                // Dragging whole annotation in SELECT mode
                if (this.selectedAnn && this.selectedAnn._drag) {
                    const dx = p.x - this.selectedAnn._drag.x, dy = p.y - this.selectedAnn._drag.y;
                    if (this.selectedAnn.points) this.selectedAnn.points = this.selectedAnn.points.map(pt => ({x:pt.x+dx,y:pt.y+dy}));
                    else if (this.selectedAnn.point) { this.selectedAnn.point.x += dx; this.selectedAnn.point.y += dy; }
                    this.selectedAnn._drag = {...p};
                }
                
                this.render();
            };
            
            this.canvas.onmouseup = (e) => {
                const p = getP(e);
                
                // Finish dragging individual point
                if (this.dragPointIndex !== null && this.selectedAnn && this.selectedAnn._dragPoint) {
                    delete this.selectedAnn._dragPoint;
                    this.dragPointIndex = null;
                    this.renderLayers();
                    return;
                }
                
                // Finish dragging whole annotation
                if (this.selectedAnn && this.selectedAnn._drag) { 
                    delete this.selectedAnn._drag; 
                    this.saveState(); 
                }
                
                // Finish drawing line (drag-to-draw: complete line on mouseup)
                if (this.drawing && this.path.length > 0) {
                    const tool = TOOLS[this.selectedTool];
                    if (tool && tool.type === 'line') {
                        // Add end point
                        this.path.push(p);
                        
                        // Create annotation with 2 points (start and end)
                        const ann = { id: 'a'+Date.now(), tool: this.selectedTool, points: this.path };
                        if (ann.tool === 'TRASSE') {
                            ann.meta = { surface: this.currentSurface, dn: this.currentDN };
                        }
                        if (this.photo.isMapSnapshot && this.photo.mapMetadata) {
                            ann.computed = { lengthMeters: this.calcLength(this.path) };
                        }
                        this.annotations.push(ann);
                        this.renderLayers();
                    }
                    this.drawing = false;
                    this.path = [];
                    this.currentMousePos = null;
                    this.render();
                }
            };
            
            this.canvas.ondblclick = (e) => {
                // Double click to edit text (no longer needed for lines)
                if (this.selectedTool === 'SELECT' && this.selectedAnn && this.selectedAnn.text !== undefined) {
                    const t = prompt('Text:', this.selectedAnn.text);
                    if (t !== null) { this.saveState(); this.selectedAnn.text = t; this.render(); }
                }
            };
            
            // Touch events
            this.canvas.ontouchstart = (e) => { 
                e.preventDefault(); 
                const t = e.touches[0]; 
                this.canvas.onmousedown({clientX:t.clientX,clientY:t.clientY}); 
            };
            this.canvas.ontouchmove = (e) => { 
                e.preventDefault(); 
                const t = e.touches[0]; 
                this.canvas.onmousemove({clientX:t.clientX,clientY:t.clientY}); 
            };
            this.canvas.ontouchend = (e) => { 
                e.preventDefault(); 
                // Get last known position for mouseup
                const rect = this.canvas.getBoundingClientRect();
                const lastPos = this.currentMousePos ? {
                    clientX: this.currentMousePos.x * this.scale + rect.left,
                    clientY: this.currentMousePos.y * this.scale + rect.top
                } : {clientX: 0, clientY: 0};
                this.canvas.onmouseup(lastPos); 
            };
        }
        
        findPointAt(p, ann) {
            if (!ann.points) return null;
            for (let i = 0; i < ann.points.length; i++) {
                if (Math.hypot(p.x - ann.points[i].x, p.y - ann.points[i].y) < 15) {
                    return i;
                }
            }
            return null;
        }
        findAt(p) {
            for (let i = this.annotations.length - 1; i >= 0; i--) {
                const a = this.annotations[i];
                if (a.points) { for (let j = 0; j < a.points.length - 1; j++) if (this.distSeg(p, a.points[j], a.points[j+1]) < 10) return a; }
                else if (a.point && Math.hypot(p.x - a.point.x, p.y - a.point.y) < 20) return a;
            }
            return null;
        }
        distSeg(p, a, b) { const dx = b.x - a.x, dy = b.y - a.y, t = Math.max(0, Math.min(1, ((p.x-a.x)*dx + (p.y-a.y)*dy) / (dx*dx+dy*dy||1))); return Math.hypot(p.x - (a.x+t*dx), p.y - (a.y+t*dy)); }
        calcLength(pts) {
            if (!this.photo.mapMetadata) return 0;
            const m = this.photo.mapMetadata, bb = m.boundingBox; let total = 0;
            for (let i = 0; i < pts.length - 1; i++) {
                const p1 = { lon: bb.west + pts[i].x * (bb.east-bb.west)/m.pixelWidth, lat: bb.north - pts[i].y * (bb.north-bb.south)/m.pixelHeight };
                const p2 = { lon: bb.west + pts[i+1].x * (bb.east-bb.west)/m.pixelWidth, lat: bb.north - pts[i+1].y * (bb.north-bb.south)/m.pixelHeight };
                const R = 6371000, dLat = (p2.lat-p1.lat)*Math.PI/180, dLon = (p2.lon-p1.lon)*Math.PI/180;
                const aa = Math.sin(dLat/2)**2 + Math.cos(p1.lat*Math.PI/180)*Math.cos(p2.lat*Math.PI/180)*Math.sin(dLon/2)**2;
                total += R * 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa));
            }
            return total;
        }
        saveState() { this.undoStack.push(JSON.stringify(this.annotations)); this.redoStack = []; if (this.undoStack.length > 50) this.undoStack.shift(); }
        undo() { if (!this.undoStack.length) return; this.redoStack.push(JSON.stringify(this.annotations)); this.annotations = JSON.parse(this.undoStack.pop()); this.selectedAnn = null; this.renderLayers(); this.render(); }
        redo() { if (!this.redoStack.length) return; this.undoStack.push(JSON.stringify(this.annotations)); this.annotations = JSON.parse(this.redoStack.pop()); this.selectedAnn = null; this.renderLayers(); this.render(); }
        deleteSelected() { if (!this.selectedAnn) return; this.saveState(); this.annotations = this.annotations.filter(a => a.id !== this.selectedAnn.id); this.selectedAnn = null; this.renderLayers(); this.render(); }
        render() {
            if (!this.ctx) return;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(this.image, 0, 0, this.canvas.width, this.canvas.height);
            this.annotations.forEach(a => this.drawAnn(a, a === this.selectedAnn));
            // Draw preview line while drawing (single straight line from start to current position)
            if (this.drawing && this.path.length > 0 && this.currentMousePos) {
                const tool = TOOLS[this.selectedTool];
                this.ctx.save();
                this.ctx.strokeStyle = tool.color;
                this.ctx.lineWidth = (tool.lineWidth || 2) * this.scale;
                if (tool.dash) this.ctx.setLineDash(tool.dash.map(d => d*this.scale)); else this.ctx.setLineDash([]);
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.globalAlpha = 0.6;
                this.ctx.beginPath();
                this.ctx.moveTo(this.path[0].x * this.scale, this.path[0].y * this.scale);
                this.ctx.lineTo(this.currentMousePos.x * this.scale, this.currentMousePos.y * this.scale);
                this.ctx.stroke();
                // Draw start point
                this.ctx.globalAlpha = 1;
                this.ctx.fillStyle = '#FFF';
                this.ctx.strokeStyle = tool.color;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([]);
                this.ctx.beginPath();
                this.ctx.arc(this.path[0].x * this.scale, this.path[0].y * this.scale, 6, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.stroke();
                this.ctx.restore();
            }
        }
        drawAnn(a, sel) {
            const tool = TOOLS[a.tool]; if (!tool) return;
            this.ctx.save();
            if (tool.type === 'line' && a.points && a.points.length > 1) {
                this.ctx.strokeStyle = tool.color; this.ctx.lineWidth = (tool.lineWidth + (sel?2:0)) * this.scale; this.ctx.lineCap = 'round';
                if (tool.dash) this.ctx.setLineDash(tool.dash.map(d => d*this.scale)); else this.ctx.setLineDash([]);
                this.ctx.beginPath(); this.ctx.moveTo(a.points[0].x * this.scale, a.points[0].y * this.scale);
                for (let i = 1; i < a.points.length; i++) this.ctx.lineTo(a.points[i].x * this.scale, a.points[i].y * this.scale);
                this.ctx.stroke();
                if (a.computed && a.computed.lengthMeters) {
                    const mid = a.points[Math.floor(a.points.length/2)], label = a.computed.lengthMeters.toFixed(1) + ' m';
                    this.ctx.font = `bold ${12*this.scale}px sans-serif`; const tw = this.ctx.measureText(label).width;
                    this.ctx.fillStyle = 'rgba(255,255,255,0.9)'; this.ctx.fillRect(mid.x*this.scale - tw/2 - 4, mid.y*this.scale - 10, tw + 8, 20);
                    this.ctx.fillStyle = tool.color; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(label, mid.x * this.scale, mid.y * this.scale);
                }
                if (sel) a.points.forEach(p => { this.ctx.fillStyle = '#FFF'; this.ctx.strokeStyle = tool.color; this.ctx.lineWidth = 2; this.ctx.setLineDash([]); this.ctx.beginPath(); this.ctx.arc(p.x*this.scale, p.y*this.scale, 8, 0, Math.PI*2); this.ctx.fill(); this.ctx.stroke(); });
            } else if (tool.type === 'point' && a.point) {
                const x = a.point.x * this.scale, y = a.point.y * this.scale, sz = (sel?18:14) * this.scale;
                this.ctx.fillStyle = tool.color; this.ctx.strokeStyle = '#FFF'; this.ctx.lineWidth = 2 * this.scale;
                if (tool.symbol === '‚óã') { this.ctx.beginPath(); this.ctx.arc(x, y, sz/2, 0, Math.PI*2); this.ctx.fill(); this.ctx.stroke(); }
                else if (tool.symbol === '‚ñ°') { this.ctx.fillRect(x-sz/2, y-sz/2, sz, sz); this.ctx.strokeRect(x-sz/2, y-sz/2, sz, sz); }
                else { this.ctx.beginPath(); this.ctx.arc(x, y, sz/2, 0, Math.PI*2); this.ctx.fill(); this.ctx.stroke(); this.ctx.strokeStyle = '#FFF'; this.ctx.beginPath(); this.ctx.moveTo(x-sz/3,y); this.ctx.lineTo(x+sz/3,y); this.ctx.moveTo(x,y-sz/3); this.ctx.lineTo(x,y+sz/3); this.ctx.stroke(); }
            } else if (tool.type === 'text' && a.point && a.text) {
                const x = a.point.x * this.scale, y = a.point.y * this.scale;
                this.ctx.font = `${14*this.scale}px sans-serif`; const tw = this.ctx.measureText(a.text).width, pad = 6*this.scale, bh = 20*this.scale;
                this.ctx.fillStyle = sel ? '#FEF3C7' : '#FFFBEB'; this.ctx.strokeStyle = sel ? '#F59E0B' : '#FCD34D'; this.ctx.lineWidth = 1;
                this.ctx.beginPath(); this.ctx.roundRect(x, y-bh/2, tw+pad*2, bh, 4); this.ctx.fill(); this.ctx.stroke();
                this.ctx.fillStyle = '#1A1A2E'; this.ctx.textAlign = 'left'; this.ctx.textBaseline = 'middle'; this.ctx.fillText(a.text, x+pad, y);
            }
            this.ctx.restore();
        }
        renderToolbar() {
            const tb = document.getElementById('editorToolbar'); tb.innerHTML = '';

            // Surface / DN global selectors
            const meta = document.createElement('div');
            meta.className = 'toolbar-meta';

            const surfaceSel = document.createElement('select');
            surfaceSel.className = 'toolbar-select';
            SURFACES.forEach(s => {
                const opt = document.createElement('option');
                opt.value = s.value; opt.textContent = s.label; surfaceSel.appendChild(opt);
            });
            surfaceSel.value = this.currentSurface;
            surfaceSel.onchange = () => { this.currentSurface = surfaceSel.value; };

            const dnSel = document.createElement('select');
            dnSel.className = 'toolbar-select';
            DNS.forEach(d => { const opt = document.createElement('option'); opt.value = d.value; opt.textContent = d.label; dnSel.appendChild(opt); });
            dnSel.value = this.currentDN;
            dnSel.onchange = () => { this.currentDN = dnSel.value; };

            const surfWrap = document.createElement('label'); surfWrap.style.display='flex'; surfWrap.style.flexDirection='column'; surfWrap.style.gap='4px';
            surfWrap.innerHTML = '<span style=\"font-size:11px;color:var(--text-secondary)\">Oberfl√§che</span>';
            surfWrap.appendChild(surfaceSel);

            const dnWrap = document.createElement('label'); dnWrap.style.display='flex'; dnWrap.style.flexDirection='column'; dnWrap.style.gap='4px';
            dnWrap.innerHTML = '<span style=\"font-size:11px;color:var(--text-secondary)\">DN</span>';
            dnWrap.appendChild(dnSel);

            meta.appendChild(surfWrap);
            meta.appendChild(dnWrap);

            tb.appendChild(meta);
            
            // Render tools with hierarchy support
            const renderTool = (tool, isNested = false) => {
                const btn = document.createElement('button');
                btn.className = 'tool-btn' + (this.selectedTool === tool.id ? ' active' : '');
                
                if (tool.type === 'group') {
                    // Group button - clicking opens submenu
                    btn.innerHTML = `<span>${tool.icon || 'üìÅ'} ${tool.name}</span><span style="font-size:10px">‚ñº</span>`;
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        // Toggle submenu
                        const existingMenu = tb.querySelector('.tool-submenu');
                        if (existingMenu) existingMenu.remove();
                        
                        const submenu = document.createElement('div');
                        submenu.className = 'tool-submenu';
                        submenu.style.cssText = 'position:absolute;background:white;border:2px solid var(--border);border-radius:8px;padding:8px;display:flex;flex-direction:column;gap:4px;z-index:100;box-shadow:var(--shadow-lg);margin-top:4px;';
                        
                        Object.values(tool.children).forEach(child => {
                            if (child.type === 'group') {
                                // Nested group
                                const groupDiv = document.createElement('div');
                                groupDiv.style.cssText = 'border-top:1px solid var(--border);padding-top:4px;margin-top:4px';
                                const groupLabel = document.createElement('div');
                                groupLabel.style.cssText = 'font-size:10px;color:var(--text-secondary);margin-bottom:4px;font-weight:600';
                                groupLabel.textContent = child.name;
                                groupDiv.appendChild(groupLabel);
                                Object.values(child.children).forEach(subchild => {
                                    const subbtn = document.createElement('button');
                                    subbtn.className = 'tool-btn';
                                    subbtn.style.cssText = 'width:100%;justify-content:flex-start;min-width:120px';
                                    subbtn.innerHTML = subchild.color ? `<span class="tool-color" style="background:${subchild.color}"></span><span>${subchild.name}</span>` : `<span>${subchild.name}</span>`;
                                    subbtn.onclick = () => {
                                        this.selectedTool = subchild.id;
                                        this.selectedAnn = null;
                                        submenu.remove();
                                        this.renderToolbar();
                                        this.render();
                                    };
                                    groupDiv.appendChild(subbtn);
                                });
                                submenu.appendChild(groupDiv);
                            } else {
                                const subbtn = document.createElement('button');
                                subbtn.className = 'tool-btn';
                                subbtn.style.cssText = 'width:100%;justify-content:flex-start;min-width:120px';
                                subbtn.innerHTML = child.color ? `<span class="tool-color" style="background:${child.color}"></span><span>${child.name}</span>` : `<span>${child.name}</span>`;
                                subbtn.onclick = () => {
                                    this.selectedTool = child.id;
                                    this.selectedAnn = null;
                                    submenu.remove();
                                    this.renderToolbar();
                                    this.render();
                                };
                                submenu.appendChild(subbtn);
                            }
                        });
                        
                        document.body.appendChild(submenu);
                        
                        // Close on outside click
                        setTimeout(() => {
                            document.addEventListener('click', function closeMenu() {
                                submenu.remove();
                                document.removeEventListener('click', closeMenu);
                            });
                        }, 10);
                    };
                } else {
                    // Regular tool button
                    btn.onclick = () => { this.selectedTool = tool.id; this.selectedAnn = null; this.renderToolbar(); this.render(); };
                    btn.innerHTML = tool.color ? `<span class="tool-color" style="background:${tool.color}"></span><span>${tool.name}</span>` : `<span>${tool.icon||''} ${tool.name}</span>`;
                }
                
                return btn;
            };
            
            Object.values(TOOL_GROUPS).forEach(tool => {
                tb.appendChild(renderTool(tool));
            });
            
            if (this.selectedAnn) {
                const del = document.createElement('button'); del.className = 'tool-btn'; del.style.cssText = 'margin-left:auto;background:#FEE2E2;color:#DC2626';
                del.innerHTML = 'üóëÔ∏è L√∂schen'; del.onclick = () => this.deleteSelected(); tb.appendChild(del);
            }
            this.updateTrasseProps();
        }
        ensureTrasseMeta(ann) {
            if (!ann) return;
            ann.meta = ann.meta || {};
            if (!ann.meta.surface) ann.meta.surface = this.currentSurface;
            if (!ann.meta.dn) ann.meta.dn = this.currentDN;
        }
        updateTrasseProps() {
            const panel = document.getElementById('trasseProps');
            if (!panel) return;
            const ann = this.selectedAnn;
            const tool = ann && TOOLS[ann.tool];
            if (!ann || !tool || tool.id !== 'TRASSE') { panel.style.display = 'none'; return; }
            this.ensureTrasseMeta(ann);
            panel.style.display = 'block';
            const surfOptions = SURFACES.map(s => `<option value="${s.value}" ${ann.meta.surface===s.value?'selected':''}>${s.label}</option>`).join('');
            const dnOptions = DNS.map(d => `<option value="${d.value}" ${ann.meta.dn===d.value?'selected':''}>${d.label}</option>`).join('');
            panel.innerHTML = `
                <h4>Trasse Eigenschaften</h4>
                <div class="row">
                    <label>Oberfl√§che</label>
                    <select data-prop="surface">${surfOptions}</select>
                    <label>DN</label>
                    <select data-prop="dn">${dnOptions}</select>
                </div>
            `;
            panel.querySelectorAll('select').forEach(sel => {
                sel.onchange = () => {
                    const prop = sel.dataset.prop;
                    ann.meta[prop] = sel.value;
                    this.render();
                    this.renderLayers();
                };
            });
        }
        renderLegend() {
            const list = document.getElementById('legendList'); list.innerHTML = '';
            Object.values(TOOLS).filter(t => t.type !== 'utility').forEach(t => {
                const item = document.createElement('div'); item.className = 'legend-item';
                item.innerHTML = t.type === 'line' ? `<span style="width:20px;height:4px;background:${t.color};border-radius:2px"></span><span>${t.name}</span>` : `<span style="color:${t.color}">${t.symbol||'‚óè'}</span><span>${t.name}</span>`;
                list.appendChild(item);
            });
        }
        renderLayers() {
            const list = document.getElementById('layerList'); list.innerHTML = '';
            if (!this.annotations.length) { list.innerHTML = '<p class="text-muted" style="font-size:12px">Keine Elemente</p>'; return; }
            [...this.annotations].reverse().forEach(a => {
                const t = TOOLS[a.tool]; if (!t) return;
                const item = document.createElement('div'); item.className = 'layer-item' + (a === this.selectedAnn ? ' selected' : '');
                item.onclick = () => { this.selectedAnn = a; this.selectedTool = 'SELECT'; if (a.tool === 'TRASSE') this.ensureTrasseMeta(a); this.renderToolbar(); this.renderLayers(); this.render(); };
                let lbl = t.name; if (a.computed?.lengthMeters) lbl += ` (${a.computed.lengthMeters.toFixed(1)}m)`; if (a.text) lbl = a.text.substring(0,20);
                item.innerHTML = `<span style="color:${t.color}">${t.symbol||'‚îÅ'}</span><span style="flex:1;overflow:hidden;text-overflow:ellipsis">${lbl}</span>`;
                list.appendChild(item);
            });
        }
        getAnnotations() { return this.annotations; }
        async renderToImage() {
            const c = document.createElement('canvas'); c.width = this.image.width; c.height = this.image.height;
            const ctx = c.getContext('2d'); ctx.drawImage(this.image, 0, 0);
            const os = this.scale, oc = this.ctx; this.scale = 1; this.ctx = ctx;
            this.annotations.forEach(a => this.drawAnn(a, false));
            this.scale = os; this.ctx = oc;
            return c.toDataURL('image/jpeg', 0.9);
        }
    }

    // MAIN APP
    class App {
        constructor() { this.db = new Database(); this.geocoder = new GeocodingService(); this.mapRenderer = null; this.editor = new Editor(); this.currentProject = null; this.currentPhoto = null; this.tempContacts = []; this.editingId = null; }
        async init() { await this.db.init(); this.renderProjectList(); }
        
        showView(id) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(id + 'View').classList.add('active');
            const back = document.getElementById('backBtn'), title = document.getElementById('headerTitle'), actions = document.getElementById('headerActions');
            if (id === 'projectList') { back.classList.remove('visible'); title.textContent = ''; actions.innerHTML = ''; }
            else if (id === 'projectForm') { back.classList.add('visible'); title.textContent = this.editingId ? 'Bearbeiten' : 'Neues Projekt'; actions.innerHTML = ''; }
            else if (id === 'projectDetail') { back.classList.add('visible'); title.textContent = this.currentProject?.projectName || ''; actions.innerHTML = '<button class="btn btn-secondary btn-sm" onclick="app.editProject()">‚úèÔ∏è</button><button class="btn btn-secondary btn-sm" onclick="app.exportProject()">üíæ</button><button class="btn btn-primary btn-sm" onclick="app.exportPDF()">PDF</button>'; }
        }
        goBack() { this.showView('projectList'); this.renderProjectList(); }

        async renderProjectList() {
            const projects = await this.db.getAll('projects'), grid = document.getElementById('projectGrid');
            if (!projects.length) { grid.innerHTML = '<div class="empty-state" style="grid-column:1/-1"><h3>Keine Projekte</h3><p>Erstellen Sie Ihr erstes Projekt</p><button class="btn btn-primary" onclick="app.showCreateProject()">+ Neues Projekt</button></div>'; return; }
            projects.sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt));
            grid.innerHTML = projects.map(p => {
                const st = {'offen':'Offen','in-arbeit':'In Arbeit','abgeschlossen':'Abgeschlossen'}[p.status] || p.status;
                return `<div class="project-card" onclick="app.openProject('${p.id}')"><div class="project-card-header"><div class="project-card-title">${this.esc(p.projectName)}</div><div class="project-card-subtitle">${this.esc(p.customer)}</div></div><div class="project-card-meta"><span>üìÖ ${new Date(p.createdAt).toLocaleDateString('de-DE')}</span><span>üìç ${this.esc(p.city||'')}</span><span class="status-badge status-${p.status}">${st}</span></div><div class="project-card-actions"><button class="project-action-btn" onclick="event.stopPropagation();app.quickCamera('${p.id}')">üì∑</button><button class="project-action-btn" onclick="event.stopPropagation();app.quickImport('${p.id}')">üìÅ</button><button class="project-action-btn" onclick="event.stopPropagation();app.exportProject('${p.id}')">üíæ</button></div></div>`;
            }).join('');
        }
        filterProjects() {
            const s = document.getElementById('searchInput').value.toLowerCase(), st = document.getElementById('statusFilter').value;
            document.querySelectorAll('.project-card').forEach(c => {
                const t = (c.querySelector('.project-card-title')?.textContent||'').toLowerCase(), sub = (c.querySelector('.project-card-subtitle')?.textContent||'').toLowerCase(), cls = c.querySelector('.status-badge')?.className||'';
                c.style.display = (!s || t.includes(s) || sub.includes(s)) && (!st || cls.includes('status-'+st)) ? '' : 'none';
            });
        }

        showCreateProject() { this.editingId = null; this.tempContacts = []; document.getElementById('projectForm').reset(); document.querySelector('[name="country"]').value = 'Deutschland'; this.renderContactList(); this.showView('projectForm'); }
        async editProject() {
            if (!this.currentProject) return;
            this.editingId = this.currentProject.id; this.tempContacts = [...(this.currentProject.contacts||[])];
            const f = document.getElementById('projectForm');
            f.projectNumber.value = this.currentProject.projectNumber||''; f.projectName.value = this.currentProject.projectName||''; f.customer.value = this.currentProject.customer||'';
            f.status.value = this.currentProject.status||'offen'; f.description.value = this.currentProject.description||'';
            f.street.value = this.currentProject.street||''; f.houseNumber.value = this.currentProject.houseNumber||'';
            f.postalCode.value = this.currentProject.postalCode||''; f.city.value = this.currentProject.city||''; f.country.value = this.currentProject.country||'Deutschland';
            f.creator.value = this.currentProject.creator||'';
            this.renderContactList(); this.showView('projectForm');
        }
        async saveProject(e) {
            e.preventDefault(); const f = e.target;
            const p = { id: this.editingId || 'p'+Date.now(), projectNumber: f.projectNumber.value, projectName: f.projectName.value, customer: f.customer.value, status: f.status.value, description: f.description.value, street: f.street.value, houseNumber: f.houseNumber.value, postalCode: f.postalCode.value, city: f.city.value, country: f.country.value, creator: f.creator.value, contacts: this.tempContacts, lat: null, lon: null, createdAt: this.editingId ? (this.currentProject?.createdAt || new Date().toISOString()) : new Date().toISOString(), updatedAt: new Date().toISOString() };
            await this.db.put('projects', p); this.toast('Gespeichert', 'success'); this.currentProject = p; await this.openProject(p.id);
        }
        cancelProjectForm() { this.goBack(); }

        showContactModal() { ['contactName','contactRole','contactPhone','contactEmail'].forEach(id => document.getElementById(id).value = ''); document.getElementById('contactModal').classList.add('active'); }
        closeContactModal() { document.getElementById('contactModal').classList.remove('active'); }
        addContact() {
            const n = document.getElementById('contactName').value.trim(); if (!n) { this.toast('Name erforderlich', 'error'); return; }
            this.tempContacts.push({ id: 'c'+Date.now(), name: n, role: document.getElementById('contactRole').value.trim(), phone: document.getElementById('contactPhone').value.trim(), email: document.getElementById('contactEmail').value.trim() });
            this.renderContactList(); this.closeContactModal();
        }
        removeContact(id) { this.tempContacts = this.tempContacts.filter(c => c.id !== id); this.renderContactList(); }
        renderContactList() {
            const list = document.getElementById('contactList');
            if (!this.tempContacts.length) { list.innerHTML = '<p class="text-muted text-center">Keine Ansprechpartner</p>'; return; }
            list.innerHTML = this.tempContacts.map(c => `<div class="contact-item"><div class="contact-avatar">${c.name.charAt(0).toUpperCase()}</div><div class="contact-info"><div class="contact-name">${this.esc(c.name)}</div><div class="contact-role">${this.esc(c.role||'-')}${c.phone?' ‚Ä¢ '+this.esc(c.phone):''}</div></div><button class="btn btn-secondary btn-sm" onclick="app.removeContact('${c.id}')">√ó</button></div>`).join('');
        }

        async openProject(id) { const p = await this.db.get('projects', id); if (!p) { this.toast('Nicht gefunden', 'error'); return; } this.currentProject = p; this.showView('projectDetail'); this.switchTab('photos'); }
        switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.toggle('active', c.id === tab+'Tab'));
            if (tab === 'photos') this.renderPhotoGrid(); else if (tab === 'map') this.initMap(); else if (tab === 'quantities') this.renderQuantityTable();
        }

        async renderPhotoGrid() {
            const photos = await this.db.getByIndex('photos', 'projectId', this.currentProject.id), grid = document.getElementById('photoGrid');
            grid.innerHTML = `<div class="photo-card add-photo-card" onclick="document.getElementById('cameraInput').click()">üì∑<br>Aufnehmen</div><div class="photo-card add-photo-card" onclick="document.getElementById('importInput').click()">üìÅ<br>Importieren</div>`;
            photos.forEach(ph => {
                const card = document.createElement('div'); card.className = 'photo-card'; card.onclick = () => this.openEditor(ph.id);
                card.innerHTML = `<img src="${ph.thumbnail||ph.dataUrl}">${ph.isMapSnapshot?'<span class="photo-card-badge">Karte</span>':''}`;
                grid.appendChild(card);
            });
        }
        async handlePhotoCapture(e) { if (e.target.files.length) { await this.addPhotos(e.target.files); e.target.value = ''; } }
        async handlePhotoImport(e) { if (e.target.files.length) { await this.addPhotos(e.target.files); e.target.value = ''; } }
        async addPhotos(files) {
            for (const f of files) {
                const dataUrl = await this.readFile(f), thumb = await this.createThumb(dataUrl, 300);
                await this.db.put('photos', { id: 'ph'+Date.now()+'_'+Math.random().toString(36).substr(2,6), projectId: this.currentProject.id, name: f.name, dataUrl, thumbnail: thumb, annotations: [], isMapSnapshot: false, mapMetadata: null, createdAt: new Date().toISOString() });
            }
            this.toast(files.length + ' Foto(s) hinzugef√ºgt', 'success'); this.renderPhotoGrid();
        }
        async quickCamera(id) { this.currentProject = await this.db.get('projects', id); document.getElementById('cameraInput').click(); }
        async quickImport(id) { this.currentProject = await this.db.get('projects', id); document.getElementById('importInput').click(); }

        async initMap() {
            const container = document.getElementById('map'), status = document.getElementById('geocodeStatus');
            console.log('initMap called, project:', this.currentProject?.projectName, 'lat:', this.currentProject?.lat, 'lon:', this.currentProject?.lon);
            
            if (!this.currentProject.lat || !this.currentProject.lon) {
                status.style.display = 'block'; status.innerHTML = '<div class="loading"></div><p class="mt-2">Adresse wird gesucht...</p>';
                
                const addrData = { 
                    street: this.currentProject.street, 
                    houseNumber: this.currentProject.houseNumber, 
                    postalCode: this.currentProject.postalCode, 
                    city: this.currentProject.city, 
                    country: this.currentProject.country 
                };
                console.log('Geocoding address:', addrData);
                
                const res = await this.geocoder.geocode(addrData);
                console.log('Geocode result:', res);
                
                if (res.error === 'NO_RESULTS') { 
                    status.innerHTML = '<div class="geocode-error"><p><b>Adresse nicht gefunden</b></p><p style="font-size:12px;margin-top:8px">Bitte pr√ºfen Sie die Adresse</p><button class="btn btn-primary btn-sm mt-2" onclick="app.editProject()">Bearbeiten</button></div>'; 
                    return; 
                }
                if (res.error === 'NETWORK_ERROR') { 
                    status.innerHTML = '<div class="geocode-error"><p><b>Netzwerkfehler</b></p><p style="font-size:12px;margin-top:8px">Keine Verbindung zu OpenStreetMap</p><button class="btn btn-secondary btn-sm mt-2" onclick="app.refreshGeocode()">Erneut versuchen</button></div>'; 
                    return; 
                }
                if (res.results.length > 1) { this.showGeocodeResults(res.results); return; }
                if (res.results.length === 1) {
                    await this.selectGeocodeResult(res.results[0]);
                    return;
                }
            }
            
            status.style.display = 'none';
            if (!this.mapRenderer) this.mapRenderer = new MapRenderer(container);
            this.mapRenderer.init(); 
            this.mapRenderer.setCenter(this.currentProject.lat, this.currentProject.lon); 
            this.mapRenderer.setZoom(18);
        }
        showGeocodeResults(results) {
            document.getElementById('geocodeResults').innerHTML = results.map((r,i) => `<div class="geocode-result-item" onclick='app.selectGeocodeResult(${JSON.stringify(r).replace(/'/g,"&#39;")})'><b>${i+1}.</b> ${this.esc(r.displayName)}</div>`).join('');
            document.getElementById('geocodeModal').classList.add('active');
        }
        closeGeocodeModal() { document.getElementById('geocodeModal').classList.remove('active'); }
        async selectGeocodeResult(r) { this.currentProject.lat = r.lat; this.currentProject.lon = r.lon; await this.db.put('projects', this.currentProject); this.closeGeocodeModal(); this.initMap(); }
        async refreshGeocode() { this.currentProject.lat = null; this.currentProject.lon = null; await this.db.put('projects', this.currentProject); this.geocoder.cache.clear(); this.initMap(); }
        mapZoom(d) { if (this.mapRenderer) this.mapRenderer.setZoom(this.mapRenderer.zoom + d); }
        async saveMapSnapshot() {
            if (!this.mapRenderer) return; this.toast('Speichern...', 'info');
            const snap = await this.mapRenderer.getSnapshot(), thumb = await this.createThumb(snap.dataUrl, 300);
            await this.db.put('photos', { id: 'ph'+Date.now(), projectId: this.currentProject.id, name: 'Karte_'+new Date().toISOString().split('T')[0]+'.png', dataUrl: snap.dataUrl, thumbnail: thumb, annotations: [], isMapSnapshot: true, mapMetadata: snap.metadata, createdAt: new Date().toISOString() });
            this.toast('Karte gespeichert', 'success'); this.switchTab('photos');
        }

        async openEditor(id) {
            const ph = await this.db.get('photos', id); if (!ph) return; this.currentPhoto = ph;
            const img = new Image();
            img.onload = () => { document.getElementById('editorTitle').textContent = ph.name; document.getElementById('editorContainer').classList.add('active'); this.editor.init(ph, img); };
            img.src = ph.dataUrl;
        }
        closeEditor() { document.getElementById('editorContainer').classList.remove('active'); this.currentPhoto = null; }
        async saveEditor() { if (!this.currentPhoto) return; this.currentPhoto.annotations = this.editor.getAnnotations(); await this.db.put('photos', this.currentPhoto); this.toast('Gespeichert', 'success'); this.closeEditor(); this.renderPhotoGrid(); }
        editorUndo() { this.editor.undo(); }
        editorRedo() { this.editor.redo(); }
        async deletePhoto() { if (!this.currentPhoto || !confirm('L√∂schen?')) return; await this.db.delete('photos', this.currentPhoto.id); this.toast('Gel√∂scht', 'success'); this.closeEditor(); this.renderPhotoGrid(); }

        async renderQuantityTable() {
            const photos = await this.db.getByIndex('photos', 'projectId', this.currentProject.id), tbody = document.getElementById('quantityTableBody');
            const qty = {};
            const addQty = (key, name, unit, type='line') => { if (!qty[key]) qty[key] = { tool: { name, unit, type }, auto: 0, manual: null }; };
            // Init non-trasse tools
            Object.values(TOOLS).filter(t => t.unit && t.id !== 'TRASSE').forEach(t => { qty[t.id] = { tool: t, auto: 0, manual: null }; });
            // Iterate annotations
            photos.forEach(ph => (ph.annotations||[]).forEach(a => {
                const t = TOOLS[a.tool]; if (!t || !t.unit) return;
                if (a.tool === 'TRASSE') {
                    a.meta = a.meta || {};
                    const surf = a.meta.surface || 'GEHWEGPLATTE';
                    const dn = a.meta.dn || 'DN50';
                    const surfLabel = (SURFACES.find(s=>s.value===surf)||{label:surf}).label;
                    const dnLabel = (DNS.find(d=>d.value===dn)||{label:dn}).label;
                    // overall trasse
                    addQty('TRASSE_TOTAL', 'Trasse gesamt', t.unit);
                    // per DN (label ohne "Trasse")
                    addQty(`TRASSE_DN_${dn}`, dnLabel, t.unit);
                    // per surface (label ohne "Trasse")
                    addQty(`TRASSE_SURF_${surf}`, surfLabel, t.unit);
                    if (a.computed?.lengthMeters) {
                        qty['TRASSE_TOTAL'].auto += a.computed.lengthMeters;
                        qty[`TRASSE_DN_${dn}`].auto += a.computed.lengthMeters;
                        qty[`TRASSE_SURF_${surf}`].auto += a.computed.lengthMeters;
                    }
                } else if (t.type === 'line' && a.computed?.lengthMeters) {
                    qty[t.id].auto += a.computed.lengthMeters;
                } else if (t.type === 'point') {
                    qty[t.id].auto += 1;
                }
            }));
            const saved = this.currentProject.quantities || {};
            Object.keys(saved).forEach(k => { if (qty[k]) qty[k].manual = saved[k]; });

            // Sort: Trasse gesamt first, dann DN, dann Oberfl√§che, dann Rest alphabetisch
            const keys = Object.keys(qty);
            const orderValue = (k) => {
                if (k === 'TRASSE_TOTAL') return 0;
                if (k.startsWith('TRASSE_DN_')) return 1;
                if (k.startsWith('TRASSE_SURF_')) return 2;
                return 3;
            };
            keys.sort((a,b) => {
                const oa = orderValue(a), ob = orderValue(b);
                if (oa !== ob) return oa - ob;
                return this.qtyLabel(a, qty[a].tool).localeCompare(this.qtyLabel(b, qty[b].tool), 'de');
            });

            let pos = 1;
            tbody.innerHTML = keys.map(id => {
                const q = qty[id];
                const autoD = q.tool.type === 'line' ? q.auto.toFixed(1) : q.auto;
                const val = q.manual !== null ? q.manual : q.auto;
                const name = this.qtyLabel(id, q.tool);
                return `<tr><td>${pos++}</td><td>${name}</td><td>${q.tool.unit}</td><td style="color:#94A3B8">${autoD}</td><td><input type="number" class="quantity-input" value="${q.tool.type==='line'?val.toFixed(1):val}" step="${q.tool.type==='line'?'0.1':'1'}" onchange="app.updateQty('${id}',this.value)"></td></tr>`;
            }).join('');
        }
        async updateQty(id, val) { if (!this.currentProject.quantities) this.currentProject.quantities = {}; this.currentProject.quantities[id] = parseFloat(val); await this.db.put('projects', this.currentProject); }
        async recalculateQuantities() {
            this.currentProject.quantities = {};
            await this.db.put('projects', this.currentProject);
            await this.renderQuantityTable();
            this.toast('Neu berechnet', 'success');
        }
        qtyLabel(id, tool) {
            if (id.startsWith('SCHACHT_AZK_')) return 'AZK ' + (tool.name || '');
            if (id.startsWith('SCHACHT_DAZK_')) return 'DAZK ' + (tool.name || '');
            return tool.name || id;
        }

        async exportProject(id) {
            const pid = id || this.currentProject?.id; if (!pid) return;
            const p = await this.db.get('projects', pid), photos = await this.db.getByIndex('photos', 'projectId', pid);
            const blob = new Blob([JSON.stringify({ version: '1.0', exportedAt: new Date().toISOString(), project: p, photos }, null, 2)], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `SiteSketch_${p.projectNumber||p.id}.json`; a.click();
            this.toast('Exportiert', 'success');
        }
        async handleJsonImport(e) {
            const f = e.target.files[0]; if (!f) return;
            try {
                const data = JSON.parse(await f.text()); if (!data.project) throw new Error('Ung√ºltig');
                const newId = 'p'+Date.now(); data.project.id = newId;
                await this.db.put('projects', data.project);
                if (data.photos) for (const ph of data.photos) { ph.id = 'ph'+Date.now()+'_'+Math.random().toString(36).substr(2,6); ph.projectId = newId; await this.db.put('photos', ph); }
                this.toast('Importiert', 'success'); this.renderProjectList();
            } catch (err) { this.toast('Fehler: ' + err.message, 'error'); }
            e.target.value = '';
        }

        async exportPDF() {
            if (!this.currentProject) return; this.toast('PDF wird erstellt...', 'info');
            const photos = await this.db.getByIndex('photos', 'projectId', this.currentProject.id);
            
            // Sammle verwendete Werkzeuge
            const usedTools = new Set();
            photos.forEach(ph => (ph.annotations||[]).forEach(a => {
                if (TOOLS[a.tool]) usedTools.add(a.tool);
            }));
            
            // Erstelle Werkzeuglegende
            let toolsLegendHtml = '';
            if (usedTools.size > 0) {
                toolsLegendHtml = '<h2>Verwendete Werkzeuge</h2><div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:10px;margin-bottom:30px">';
                usedTools.forEach(toolId => {
                    const t = TOOLS[toolId];
                    const colorSquare = `<div style="width:20px;height:20px;background:${t.color};border-radius:4px;margin:0 auto 5px"></div>`;
                    toolsLegendHtml += `<div style="border:1px solid #ddd;padding:10px;border-radius:8px;text-align:center">${colorSquare}<div style="font-size:12px;font-weight:bold">${t.name}</div></div>`;
                });
                toolsLegendHtml += '</div>';
            }
            
            let photosHtml = '';
            for (const ph of photos) {
                let src = ph.dataUrl;
                if (ph.annotations && ph.annotations.length) {
                    const img = new Image(); await new Promise(r => { img.onload = r; img.src = ph.dataUrl; });
                    this.editor.photo = ph; this.editor.image = img; this.editor.annotations = ph.annotations;
                    src = await this.editor.renderToImage();
                }
                photosHtml += `<div style="page-break-inside:avoid;margin-bottom:20px"><img src="${src}" style="max-width:100%;max-height:450px;display:block;margin:0 auto"></div>`;
            }
            
            // PDF im Querformat mit getrennten Sektionen f√ºr Projekt, Kunde und Ersteller
            const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Projektbericht</title>
<style>
@page { size: landscape; margin: 15mm; }
@media print { @page { size: landscape; margin: 15mm; } }
body { font-family: Arial, sans-serif; padding: 20px; margin: 0; }
h1 { color: #0066FF; border-bottom: 2px solid #0066FF; padding-bottom: 10px; margin-bottom: 20px; }
h2 { margin-top: 25px; color: #333; font-size: 16px; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
.info-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 30px; }
.info-section { background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0; }
.info-section-title { font-weight: bold; color: #0066FF; margin-bottom: 10px; font-size: 14px; text-transform: uppercase; }
.info-row { display: flex; margin: 6px 0; font-size: 13px; }
.info-label { width: 100px; font-weight: 500; color: #64748b; }
.info-value { flex: 1; color: #1a1a2e; }
.description { background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
table { width: 100%; border-collapse: collapse; }
th, td { border: 1px solid #ddd; padding: 8px; text-align: left; font-size: 12px; }
th { background: #f5f5f5; }
</style></head><body>
<h1>Projektbericht</h1>

<div class="info-grid">
    <div class="info-section">
        <div class="info-section-title">üìÅ Projekt</div>
        <div class="info-row"><span class="info-label">Nummer:</span><span class="info-value">${this.esc(this.currentProject.projectNumber||'-')}</span></div>
        <div class="info-row"><span class="info-label">Name:</span><span class="info-value">${this.esc(this.currentProject.projectName)}</span></div>
        <div class="info-row"><span class="info-label">Status:</span><span class="info-value">${this.esc(this.currentProject.status||'-')}</span></div>
        <div class="info-row"><span class="info-label">Datum:</span><span class="info-value">${new Date().toLocaleDateString('de-DE')}</span></div>
    </div>
    
    <div class="info-section">
        <div class="info-section-title">üë§ Kunde</div>
        <div class="info-row"><span class="info-label">Name:</span><span class="info-value">${this.esc(this.currentProject.customer)}</span></div>
        <div class="info-row"><span class="info-label">Stra√üe:</span><span class="info-value">${this.esc(this.currentProject.street||'')} ${this.esc(this.currentProject.houseNumber||'')}</span></div>
        <div class="info-row"><span class="info-label">Ort:</span><span class="info-value">${this.esc(this.currentProject.postalCode||'')} ${this.esc(this.currentProject.city||'')}</span></div>
        <div class="info-row"><span class="info-label">Land:</span><span class="info-value">${this.esc(this.currentProject.country||'Deutschland')}</span></div>
    </div>
    
    <div class="info-section">
        <div class="info-section-title">‚úèÔ∏è Ersteller</div>
        <div class="info-row"><span class="info-label">Name:</span><span class="info-value">${this.esc(this.currentProject.creator||'-')}</span></div>
        <div class="info-row"><span class="info-label">Erstellt:</span><span class="info-value">${this.currentProject.createdAt ? new Date(this.currentProject.createdAt).toLocaleDateString('de-DE') : '-'}</span></div>
        <div class="info-row"><span class="info-label">Aktualisiert:</span><span class="info-value">${this.currentProject.updatedAt ? new Date(this.currentProject.updatedAt).toLocaleDateString('de-DE') : '-'}</span></div>
    </div>
</div>

${this.currentProject.description ? '<div class="description"><strong>Beschreibung:</strong> '+this.esc(this.currentProject.description)+'</div>' : ''}

${toolsLegendHtml}

<h2>üì∑ Fotos (${photos.length})</h2>
${photosHtml || '<p>Keine Fotos vorhanden</p>'}

</body></html>`;
            
            const w = window.open('','_blank'); 
            w.document.write(html); 
            w.document.close(); 
            setTimeout(() => w.print(), 500);
        }
        async exportQuantityPDF() {
            if (!this.currentProject) return;
            const photos = await this.db.getByIndex('photos', 'projectId', this.currentProject.id);
            const qty = {};
            const addQty = (key, name, unit, type='line') => { if (!qty[key]) qty[key] = { tool: { name, unit, type }, auto: 0 }; };
            Object.values(TOOLS).filter(t => t.unit && t.id !== 'TRASSE').forEach(t => { qty[t.id] = { tool: t, auto: 0 }; });
            photos.forEach(ph => (ph.annotations||[]).forEach(a => {
                const t = TOOLS[a.tool]; if (!t || !t.unit) return;
                if (a.tool === 'TRASSE') {
                    a.meta = a.meta || {};
                    const surf = a.meta.surface || 'GEHWEGPLATTE';
                    const dn = a.meta.dn || 'DN50';
                    const surfLabel = (SURFACES.find(s=>s.value===surf)||{label:surf}).label;
                    const dnLabel = (DNS.find(d=>d.value===dn)||{label:dn}).label;
                    addQty('TRASSE_TOTAL', 'Trasse gesamt', t.unit);
                    addQty(`TRASSE_DN_${dn}`, dnLabel, t.unit);
                    addQty(`TRASSE_SURF_${surf}`, surfLabel, t.unit);
                    if (a.computed?.lengthMeters) {
                        qty['TRASSE_TOTAL'].auto += a.computed.lengthMeters;
                        qty[`TRASSE_DN_${dn}`].auto += a.computed.lengthMeters;
                        qty[`TRASSE_SURF_${surf}`].auto += a.computed.lengthMeters;
                    }
                } else if (t.type === 'line' && a.computed?.lengthMeters) {
                    qty[t.id].auto += a.computed.lengthMeters;
                } else if (t.type === 'point') {
                    qty[t.id].auto += 1;
                }
            }));
            const saved = this.currentProject.quantities || {};
            const keys = Object.keys(qty).sort((a,b) => {
                const orderValue = k => k==='TRASSE_TOTAL'?0: k.startsWith('TRASSE_DN_')?1: k.startsWith('TRASSE_SURF_')?2:3;
                const oa = orderValue(a), ob = orderValue(b);
                if (oa !== ob) return oa - ob;
                return this.qtyLabel(a, qty[a].tool).localeCompare(this.qtyLabel(b, qty[b].tool), 'de');
            });
            let pos = 1, rows = keys.map(id => {
                const q = qty[id];
                const val = saved[id] !== undefined ? saved[id] : q.auto;
                const name = this.qtyLabel(id, q.tool);
                return `<tr><td>${pos++}</td><td>${name}</td><td>${q.tool.unit}</td><td style="text-align:right">${q.tool.type==='line'?val.toFixed(1):val}</td></tr>`;
            }).join('');
            
            const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Mengenaufma√ü</title>
<style>
@page { size: landscape; margin: 15mm; }
@media print { @page { size: landscape; margin: 15mm; } }
body { font-family: Arial, sans-serif; padding: 20px; }
h1 { color: #0066FF; margin-bottom: 20px; }
.info-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 30px; }
.info-section { background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0; }
.info-section-title { font-weight: bold; color: #0066FF; margin-bottom: 10px; font-size: 13px; text-transform: uppercase; }
.info-row { margin: 5px 0; font-size: 13px; }
table { width: 100%; border-collapse: collapse; margin-top: 20px; }
th, td { border: 1px solid #ddd; padding: 10px; }
th { background: #0066FF; color: white; }
</style></head><body>
<h1>Mengenaufma√ü</h1>

<div class="info-grid">
    <div class="info-section">
        <div class="info-section-title">üìÅ Projekt</div>
        <div class="info-row"><b>Nummer:</b> ${this.esc(this.currentProject.projectNumber||'-')}</div>
        <div class="info-row"><b>Name:</b> ${this.esc(this.currentProject.projectName)}</div>
    </div>
    <div class="info-section">
        <div class="info-section-title">üë§ Kunde</div>
        <div class="info-row"><b>Name:</b> ${this.esc(this.currentProject.customer)}</div>
        <div class="info-row"><b>Adresse:</b> ${this.esc(this.currentProject.street||'')} ${this.esc(this.currentProject.houseNumber||'')}, ${this.esc(this.currentProject.postalCode||'')} ${this.esc(this.currentProject.city||'')}</div>
    </div>
    <div class="info-section">
        <div class="info-section-title">‚úèÔ∏è Ersteller</div>
        <div class="info-row"><b>Name:</b> ${this.esc(this.currentProject.creator||'-')}</div>
        <div class="info-row"><b>Datum:</b> ${new Date().toLocaleDateString('de-DE')}</div>
    </div>
</div>

<table>
    <tr><th>Pos.</th><th>Beschreibung</th><th>Einheit</th><th style="text-align:right">Menge</th></tr>
    ${rows}
</table>
</body></html>`;
            
            const w = window.open('','_blank'); 
            w.document.write(html); 
            w.document.close(); 
            setTimeout(() => w.print(), 500);
        }

        readFile(f) { return new Promise((r,e) => { const fr = new FileReader(); fr.onload = () => r(fr.result); fr.onerror = e; fr.readAsDataURL(f); }); }
        createThumb(dataUrl, max) { return new Promise(r => { const img = new Image(); img.onload = () => { const c = document.createElement('canvas'), s = Math.min(max/img.width, max/img.height, 1); c.width = img.width*s; c.height = img.height*s; c.getContext('2d').drawImage(img, 0, 0, c.width, c.height); r(c.toDataURL('image/jpeg', 0.7)); }; img.src = dataUrl; }); }
        esc(s) { return s ? String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;') : ''; }
        toast(msg, type='info') { const c = document.getElementById('toastContainer'), t = document.createElement('div'); t.className = 'toast ' + type; t.textContent = msg; c.appendChild(t); setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 3000); }
    }

    const app = new App();
    app.init();
    window.addEventListener('resize', () => { if (app.mapRenderer) app.mapRenderer.resize(); });
    </script>
</body>
</html>
